# デプロイワークフローのイメージとコンテナ管理

## 概要

このドキュメントでは、本プロジェクトのGitHub Actionsデプロイワークフローにおいて、Dockerイメージとコンテナがどのように管理されているかを解説します。

## デプロイワークフローの構成

デプロイワークフローは2つのジョブで構成されています：

1. **build-and-push**: GitHub Container Registry (GHCR) へのイメージビルド・プッシュ
2. **deploy**: self-hosted runner上での本番サーバへのデプロイ

## Dockerイメージの管理

### イメージタグ戦略

ワークフローでは、各Dockerイメージ（app/web/db）に対して3種類のタグが付与されます：

**ファイル**: [.github/workflows/deploy-production.yml:47-50](.github/workflows/deploy-production.yml#L47-L50)

```yaml
tags: |
  ${{ env.REGISTRY }}/${{ github.repository }}/app:latest
  ${{ env.REGISTRY }}/${{ github.repository }}/app:${{ steps.meta.outputs.timestamp }}
  ${{ env.REGISTRY }}/${{ github.repository }}/app:${{ steps.meta.outputs.sha_short }}
```

#### 3つのタグの意味

| タグ | 形式 | 用途 | 動作 |
|------|------|------|------|
| `latest` | 固定文字列 | 常に最新バージョンを指す | 上書きされる（新しいダイジェストで置き換わる） |
| タイムスタンプ | `YYYYMMDD-HHMMSS` | 特定時刻のデプロイを特定 | デプロイ毎に新規作成 |
| コミットSHA | 先頭7文字 | 特定コミットのイメージを特定 | コミット毎に新規作成 |

### イメージの更新プロセス

**ファイル**: [deploy/scripts/deploy.sh:92](deploy/scripts/deploy.sh#L92)

```bash
# 最新のイメージをPull
log_info "Pulling latest Docker images from registry..."
docker compose pull
```

1. `docker compose pull` コマンドで `latest` タグのイメージを取得
2. ローカルの `latest` タグは新しいイメージダイジェストで上書きされる
3. 以前の `latest` タグが指していたイメージは、他のタグ（タイムスタンプ・SHA）がある場合は残る

### 古いイメージのクリーンアップ

**ファイル**: [deploy/scripts/deploy.sh:264](deploy/scripts/deploy.sh#L264)

```bash
# クリーンアップ（古いイメージの削除）
log_info "Cleaning up old Docker images..."
docker image prune -f
```

デプロイの最終段階で `docker image prune -f` が実行されます：

- **削除されるイメージ**: いずれのコンテナからも使用されていない（dangling）イメージのみ
- **保持されるイメージ**:
  - 現在実行中のコンテナが使用しているイメージ
  - タグ付きイメージ（タイムスタンプ、SHA）

## Dockerコンテナの管理

### コンテナの再作成プロセス

**ファイル**: [deploy/scripts/deploy.sh:99-103](deploy/scripts/deploy.sh#L99-L103)

```bash
# コンテナの停止と削除（データベースボリュームは保持）
log_info "Stopping existing containers..."
docker compose down --remove-orphans

# コンテナの起動
log_info "Starting containers..."
docker compose up -d
```

#### 動作の詳細

1. **`docker compose down --remove-orphans`**
   - 既存のコンテナを停止
   - コンテナを削除
   - ネットワークも削除
   - **データボリュームは保持**（`--volumes` フラグを使用していないため）
   - 孤立したコンテナも削除（`--remove-orphans`）

2. **`docker compose up -d`**
   - 新しいコンテナをバックグラウンドで起動
   - 最新のイメージを使用
   - 既存のボリュームを再マウント

### データの永続性

コンテナは毎回削除・再作成されますが、データは保持されます：

| データ種別 | 保持方法 | 理由 |
|-----------|---------|------|
| データベースデータ | Dockerボリューム | `docker compose down` で `--volumes` フラグを使用していない |
| アプリケーション設定 | `.env` ファイル | ホスト側のデプロイディレクトリに配置 |
| アップロードファイル | Dockerボリューム（設定による） | docker-compose.ymlでボリュームマウント設定 |

## デプロイフロー全体図

```
┌─────────────────────────────────────────────────────────────┐
│ 1. GitHub Actions (ubuntu-latest runner)                    │
│    - Dockerイメージのビルド                                   │
│    - GHCRへプッシュ (latest, timestamp, sha)                 │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. 本番サーバ (self-hosted runner)                           │
│    ┌───────────────────────────────────────────────────┐    │
│    │ a. docker compose pull                           │    │
│    │    → 'latest'タグのイメージを取得                  │    │
│    │    → ローカルイメージを上書き                       │    │
│    └───────────────────────────────────────────────────┘    │
│    ┌───────────────────────────────────────────────────┐    │
│    │ b. docker compose down --remove-orphans          │    │
│    │    → 既存コンテナを停止・削除                       │    │
│    │    → ボリュームは保持                              │    │
│    └───────────────────────────────────────────────────┘    │
│    ┌───────────────────────────────────────────────────┐    │
│    │ c. docker compose up -d                          │    │
│    │    → 新しいコンテナを起動                          │    │
│    │    → 既存ボリュームを再マウント                     │    │
│    └───────────────────────────────────────────────────┘    │
│    ┌───────────────────────────────────────────────────┐    │
│    │ d. マイグレーション・キャッシュ最適化               │    │
│    └───────────────────────────────────────────────────┘    │
│    ┌───────────────────────────────────────────────────┐    │
│    │ e. docker image prune -f                         │    │
│    │    → 未使用イメージのみ削除                        │    │
│    │    → タグ付きイメージは保持                        │    │
│    └───────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

## まとめ

### イメージ管理

- ✅ **`latest`タグ**: デプロイ毎に上書きされる（新しいダイジェストに更新）
- ✅ **タイムスタンプ・SHAタグ**: デプロイ毎に新規作成され、保持される
- ✅ **未使用イメージ**: `docker image prune -f` で自動削除
- ✅ **ロールバック可能**: 過去のタグを指定して特定バージョンに戻せる

### コンテナ管理

- ✅ **コンテナ**: 毎回削除・再作成される
- ✅ **データボリューム**: 保持される（データベース、アップロードファイルなど）
- ✅ **ネットワーク**: 毎回削除・再作成される
- ✅ **設定ファイル**: ホスト側のデプロイディレクトリで管理

### メリット

1. **クリーンな環境**: 毎回コンテナを作り直すため、環境が常にクリーンな状態
2. **ロールバック対応**: 過去のイメージタグが保持されるため、問題発生時に戻せる
3. **ディスク容量管理**: 未使用イメージは自動削除されるため、ディスク圧迫を防止
4. **データ保護**: ボリュームは保持されるため、データベースやアップロードファイルは失われない

### 注意点

- タグ付きイメージは自動削除されないため、長期間運用すると古いイメージが蓄積する可能性がある
- 必要に応じて手動で古いタグのイメージを削除する運用を検討

## 関連ファイル

- [.github/workflows/deploy-production.yml](.github/workflows/deploy-production.yml) - デプロイワークフロー定義
- [deploy/scripts/deploy.sh](deploy/scripts/deploy.sh) - デプロイスクリプト
- [deploy/prod/docker-compose.yml](deploy/prod/docker-compose.yml) - 本番環境のDocker Compose設定
